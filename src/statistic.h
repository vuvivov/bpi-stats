#pragma once
#include "priceDatabase.h"
#include <list>
#include <array>
#include <memory>
#include <limits>
#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics/stats.hpp>
#include <boost/accumulators/statistics/mean.hpp>
#include <boost/accumulators/statistics/variance.hpp>
using namespace boost::accumulators;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///Abstract class for statistics calculated from accumulated data. 
///Non-virtual functions define the basic work flow. Derived classes should define detailed calculation methods of particular statistics.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class statistic
{
protected:
	unsigned int m_count = 0;///<number of data points accumulated
	std::list<std::array<std::string, 2>> m_output;///<member for manipulation of output strings;
												   ///contains a list of attributes of the statistic; column 1=name,column 1=value; 
												   ///needs to be initialized in constructor of children with the first column containing attribute name
public:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Add one data point for accumulation
	///@param _data: data point
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void accumulate(const pricePoint _data) { m_count++; accumulateDetail(_data);}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Output statistic to strings
	///@return: a list of atribute name-value pairs
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	decltype(m_output) toStrings();

private:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Details for accumulation; should be overriden according to specific statistic
	///@param _data: data point
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void accumulateDetail(const pricePoint _data) = 0;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Details for output statistic to strings; should be overriden according to specific statistic
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void toStringsDetail() = 0;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///Abstract class that manages the initialization, accumulation, output, etc of a collection of statistics.
///Constructors of derived classes should define what statistics are to be managed.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class statisticsManager
{
protected:
	std::list<std::unique_ptr<statistic>> m_statistics;///<collection of statistics
//private:
	statisticsManager() =default;
public:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Add one data point for accumulation for each statistic
	///@param _data: data point
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void accumulate(const pricePoint _data);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Output statistics to strings
	///@return: a list of outputs of statistic::toStrings()
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	std::list<std::list<std::array<std::string,2>>> print();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///A statistics manager customized to the statistics asked by bluzelle
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class bluzelleStatisticsManager : public statisticsManager
{
public:
	bluzelleStatisticsManager();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///High/low prices with dates
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class highLow : public statistic
{
	double m_high = std::numeric_limits<double>::min();
	double m_low = std::numeric_limits<double>::max();
	std::list<boost::gregorian::date> m_highDates;
	std::list<boost::gregorian::date> m_lowDates;
public:
	highLow() { m_output = decltype(m_output){ {"Highest price and date(s)", ""}, { "Lowest price and date(s)", "" }}; }
	virtual void accumulateDetail(const pricePoint _data) override;
	virtual void toStringsDetail() override;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///A abtract class template for simple statistics with single attribute.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
class simpleStat : public statistic
{
protected:
	std::string m_name;///<attribute name; needs to be defined in children's constructor
	T m_data;///<attribute value, to be calculated
private:
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Details for accumulation; should be overriden according to specific statistic
	///@param _data: data point
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void accumulateDetail(const pricePoint _data) = 0;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Implementaion of details for any statistic output to strings
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void toStringsDetail() final;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///Calculate statistic to get ready for exporting to string
	///@return: none
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	virtual void calculate() = 0;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///The number of data points in the time span
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class nPoints : public simpleStat<int>
{
public:
	nPoints() {m_name="The number of data points in the time span"; }
private:
	virtual void accumulateDetail(const pricePoint _data) override {};
	virtual void calculate() override {m_data = m_count;	}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///The average price for the time span
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class averagePrice : public simpleStat<double>
{
	accumulator_set<double, stats<tag::mean> > m_acc;
public:
	averagePrice() {m_name="The average price for the time span";}
	virtual void accumulateDetail(const pricePoint _data) override { m_acc(_data.second); }
	virtual void calculate() override { m_data = mean(m_acc); }
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///The median price for the time span
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class medianPrice : public simpleStat<double>
{
	std::list<double> m_prices;///<keep prices for final calculation
							   ///algorithm implemented in house since boost::median does not handle very small data set well
public:
	medianPrice() {m_name="The median price for the time span";}
	virtual void accumulateDetail(const pricePoint _data) override { m_prices.push_back(_data.second); }
	virtual void calculate() override;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///The standard deviation of the prices for the time span
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class stdDevPrice : public simpleStat<double>
{
	accumulator_set<double, stats<tag::variance> > m_acc;
public:
	stdDevPrice() {m_name="The standard deviation of the prices for the time span";}
	virtual void accumulateDetail(const pricePoint _data) override { m_acc(_data.second); }
	virtual void calculate() override { m_data = std::sqrt(variance(m_acc)); }
};

